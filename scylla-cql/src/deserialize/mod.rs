#![doc = include_str!("README.md")]

pub mod frame_slice;
pub mod result;
pub mod row;
pub mod value;

pub use frame_slice::FrameSlice;

use std::error::Error;
use std::sync::Arc;

use thiserror::Error;

// Errors

/// An error indicating that a failure happened during type check.
///
/// The error is type-erased so that the crate users can define their own
/// type check impls and their errors.
/// As for the impls defined or generated
/// by the driver itself, the following errors can be returned:
///
/// - [`row::BuiltinTypeCheckError`] is returned when type check of
///   one of types with an impl built into the driver fails. It is also returned
///   from impls generated by the `DeserializeRow` macro.
/// - [`value::BuiltinTypeCheckError`] is analogous to the above but is
///   returned from [`DeserializeValue::type_check`](value::DeserializeValue::type_check)
///   instead both in the case of builtin impls and impls generated by the
///   `DeserializeValue` macro.
///   It won't be returned by the `Session` directly, but it might be nested
///   in the [`row::BuiltinTypeCheckError`].
#[derive(Debug, Clone, Error)]
#[error("TypeCheckError: {0}")]
pub struct TypeCheckError(pub(crate) Arc<dyn std::error::Error + Send + Sync>);

impl TypeCheckError {
    /// Constructs a new `TypeCheckError`.
    #[inline]
    pub fn new(err: impl std::error::Error + Send + Sync + 'static) -> Self {
        Self(Arc::new(err))
    }

    /// Retrieve an error reason by downcasting to specific type.
    pub fn downcast_ref<T: std::error::Error + 'static>(&self) -> Option<&T> {
        self.0.downcast_ref()
    }
}

/// An error indicating that a failure happened during deserialization.
///
/// The error is type-erased so that the crate users can define their own
/// deserialization impls and their errors. As for the impls defined or generated
/// by the driver itself, the following errors can be returned:
///
/// - [`row::BuiltinDeserializationError`] is returned when deserialization of
///   one of types with an impl built into the driver fails. It is also returned
///   from impls generated by the `DeserializeRow` macro.
/// - [`value::BuiltinDeserializationError`] is analogous to the above but is
///   returned from [`DeserializeValue::deserialize`](value::DeserializeValue::deserialize)
///   instead both in the case of builtin impls and impls generated by the
///   `DeserializeValue` macro.
///   It won't be returned by the `Session` directly, but it might be nested
///   in the [`row::BuiltinDeserializationError`].
#[derive(Debug, Clone, Error)]
#[error("DeserializationError: {0}")]
pub struct DeserializationError(Arc<dyn Error + Send + Sync>);

impl DeserializationError {
    /// Constructs a new `DeserializationError`.
    #[inline]
    pub fn new(err: impl Error + Send + Sync + 'static) -> Self {
        Self(Arc::new(err))
    }

    /// Retrieve an error reason by downcasting to specific type.
    pub fn downcast_ref<T: Error + 'static>(&self) -> Option<&T> {
        self.0.downcast_ref()
    }
}

// This is a hack to enable setting the proper Rust type name in error messages,
// even though the error originates from some helper type used underneath.
// ASSUMPTION: This should be used:
// - ONLY in proper type_check()/deserialize() implementation,
// - BEFORE an error is cloned (because otherwise the Arc::get_mut fails).
macro_rules! make_error_replace_rust_name {
    ($privacy: vis, $fn_name: ident, $outer_err: ty, $inner_err: ident) => {
        // Not part of the public API; used in derive macros.
        #[doc(hidden)]
        #[allow(clippy::needless_pub_self)]
        $privacy fn $fn_name<RustT>(mut err: $outer_err) -> $outer_err {
            let rust_name = std::any::type_name::<RustT>();
            match std::sync::Arc::get_mut(&mut err.0) {
                Some(arc_mut) => {
                    if let Some(err) = arc_mut.downcast_mut::<$inner_err>() {
                        err.rust_name = rust_name;
                    }
                },
                None => {
                    if let Some(err) = err.0.downcast_ref::<$inner_err>() {
                        if err.rust_name != rust_name {
                            return <$outer_err>::new($inner_err {
                                rust_name,
                                ..err.clone()
                            });
                        }
                    }
                }
            }

            err
        }
    };
}
use make_error_replace_rust_name;

#[cfg(test)]
pub(crate) mod tests {
    use bytes::{Bytes, BytesMut};

    use crate::frame::response::result::{ColumnSpec, ColumnType, TableSpec};
    use crate::frame::types;

    pub(super) static CELL1: &[u8] = &[1, 2, 3];
    pub(super) static CELL2: &[u8] = &[4, 5, 6, 7];

    pub(super) fn serialize_cells(
        cells: impl IntoIterator<Item = Option<impl AsRef<[u8]>>>,
    ) -> Bytes {
        let mut bytes = BytesMut::new();
        for cell in cells {
            types::write_bytes_opt(cell, &mut bytes).unwrap();
        }
        bytes.freeze()
    }

    pub(crate) const fn spec<'a>(name: &'a str, typ: ColumnType<'a>) -> ColumnSpec<'a> {
        ColumnSpec::borrowed(name, typ, TableSpec::borrowed("ks", "tbl"))
    }
}
